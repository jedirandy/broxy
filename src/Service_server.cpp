// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <curl/curl.h>
#include <boost/program_options.hpp>

#include "Service.h"
#include "Util.h"
#include "Cache.h"
#include <chrono>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace std;
using boost::shared_ptr;
using namespace ::broxy;

class ServiceHandler: virtual public ServiceIf {
public:
	std::shared_ptr<Cache> cache;
	ServiceHandler(CachePolicy policy, size_t cache_size) {
		switch (policy) {
		case FIFO:
			cache.reset(new FIFOCache(cache_size));
			break;
		case LRU:
			cache.reset(new LRUCache(cache_size));
			break;
		case MAXS:
			cache.reset(new MAXSCache(cache_size));
			break;
		case RANDOM:
			cache.reset(new RandomCache(cache_size));
			break;
		default:
			break;
		}
	}

	~ServiceHandler() {
	}

	void get(Response& _return, const Request& req) {
		Response res;
		if (req.url == "@stats") {
			res.code = 200;
			res.body = cache->get_stats();
			_return = res;
			return;
		}
		auto start = std::chrono::system_clock::now();
		cout << "client is requesting " << req.url << endl;
		auto buf = cache->fetch(req.url);
		auto end = std::chrono::system_clock::now();
		cout << chrono::duration<double, milli>(end - start).count() << " ms" << endl;
		res.code = 200;
		res.body = buf;
		_return = res;
	}
};

int main(int argc, char **argv) {
	int port = 9090;
	CachePolicy policy = FIFO;
	size_t cache_size = 0;
	if (argc != 3) {
		cout << "args: policy cache_size" << endl;
		return EXIT_FAILURE;
	} else {
		policy = (CachePolicy) atoi(argv[1]);
		cache_size = atoi(argv[2]);
		if (policy >= NUM_OF_POLICIES || policy <= ZERO_POLICY) {
			cout << "invalid policy" << endl;
			return EXIT_FAILURE;
		}
		if (cache_size < 0) {
			cout << "invalid cache size" << endl;
			return EXIT_FAILURE;
		}
	}
	boost::shared_ptr<ServiceHandler> handler(
			new ServiceHandler(policy, cache_size));
	boost::shared_ptr<TProcessor> processor(new ServiceProcessor(handler));
	boost::shared_ptr<TServerTransport> serverTransport(
			new TServerSocket(port));
	boost::shared_ptr<TTransportFactory> transportFactory(
			new TBufferedTransportFactory());
	boost::shared_ptr<TProtocolFactory> protocolFactory(
			new TBinaryProtocolFactory());

	TSimpleServer server(processor, serverTransport, transportFactory,
			protocolFactory);
	cout << "Server started, policy: " << policy_to_string(policy)
			<< " cache size: " << cache_size << " Bytes" << endl;
	server.serve();
	return EXIT_SUCCESS;
}

