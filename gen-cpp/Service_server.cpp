// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Service.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <curl/curl.h>

#include "Util.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace std;
using boost::shared_ptr;
using namespace ::broxy;

class ServiceHandler: virtual public ServiceIf {
public:
	Cache* cache;
	ServiceHandler() {
		// init
		cache = new FIFOCache(64 * 1024);
	}

	~ServiceHandler() {
		delete cache;
	}

	void get(Response& _return, const Request& req) {
		// Your implementation goes here
		cout << "client is requesting " << req.url << endl;
		Response r;
		cout << "cache available size: " << cache->available() << endl;
		auto buf = cache->fetch(req.url);
		r.code = 200;
		r.body = buf;
		_return = r;
	}
};

int main(int argc, char **argv) {
	int port = 9090;
	boost::shared_ptr<ServiceHandler> handler(new ServiceHandler());
	boost::shared_ptr<TProcessor> processor(new ServiceProcessor(handler));
	boost::shared_ptr<TServerTransport> serverTransport(
			new TServerSocket(port));
	boost::shared_ptr<TTransportFactory> transportFactory(
			new TBufferedTransportFactory());
	boost::shared_ptr<TProtocolFactory> protocolFactory(
			new TBinaryProtocolFactory());

	TSimpleServer server(processor, serverTransport, transportFactory,
			protocolFactory);
	cout << "Server started" << endl;
	server.serve();
	return 0;
}

